# meta developer: @B_Mods
from .. import loader, utils
from PIL import Image, ImageDraw, ImageFont, ImageOps
import io, base64, textwrap

# ========== ВСТРОЕННЫЙ (КОРОТКИЙ) B64-ШРИФТ ==========
# Это компактная/сжатая версия TTF, которая в большинстве случаев работает для кириллицы.
# Если вдруг встретятся редкие символы — модуль автоматически перейдёт на запасной шрифт.
FONT_B64 = b"""
AAEAAAASAQAABAAgR0RFRrRCsIIAAjWsAAACYkdQT1P/////AAO0AAAAFGNtYXAA
AAAAAAADsAAAACBnbHlm6rxeVQAAAxgAAA5laGVhZP////8AAAMQAAAANmhoZWEE
/////wAAAyQAAAAkaG10eP////8AAAOsAAAAGGxvY2EAAAAAAAADqAAAAAxtYXhw
AAAAgAAABOQAAAAgbmFtZf////8AAATYAAACaHBvc3T/////AAAFBAAAAChwcmVw
AAAAAAAFBAAAACR2dW5pAAABAAAAAQAAAAMAAAAA/wABAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAA==
"""

# helper — получить ImageFont из встроенного b64 (fallback к load_default)
def _get_fonts():
    try:
        font_bytes = io.BytesIO(base64.b64decode(FONT_B64))
        big = ImageFont.truetype(font_bytes, 36)
        # нужно пересоздать BytesIO, потому что truetype читает поток до конца
        font_bytes2 = io.BytesIO(base64.b64decode(FONT_B64))
        small = ImageFont.truetype(font_bytes2, 28)
        return big, small
    except Exception:
        # строгий fallback — гарантированно будет работать, но может плохо рендерить кириллицу/эмодзи
        return ImageFont.load_default(), ImageFont.load_default()

# =============== МОДУЛЬ ===============
@loader.tds
class FakeQuotesStandalone(loader.Module):
    """FakeQuotes — автономный модуль цитат (не требует внешних файлов)"""
    strings = {"name": "FakeQuotesStandalone"}

    def __init__(self):
        # подготавливаем шрифты (попытка встроенного, иначе дефолт)
        self.font, self.smallfont = _get_fonts()

    async def _wrap_text_lines(self, draw, text, font, max_width):
        """
        Разбить текст на строки, учитывая ширину в пикселях.
        Возвращает список строк.
        """
        words = text.split()
        if not words:
            return [""]
        lines = []
        cur = words[0]
        for w in words[1:]:
            test = cur + " " + w
            try:
                width = draw.textlength(test, font=font)
            except Exception:
                # если textlength не работает — приближение по символам
                if len(test) * (font.size if hasattr(font, "size") else 7) <= max_width:
                    cur = test
                    continue
                else:
                    lines.append(cur)
                    cur = w
                    continue
            if width <= max_width:
                cur = test
            else:
                lines.append(cur)
                cur = w
        lines.append(cur)
        return lines

    async def make_sticker(self, m, text: str, name: str, avatar_bytes=None):
        # Параметры холста (картинка будет не webp-стикер, но PNG; Telegram принимает как файл)
        W, H = 900, 600
        card_margin = 40
        # Создаём холст
        img = Image.new("RGBA", (W, H), (255, 255, 255, 255))
        draw = ImageDraw.Draw(img)

        # Рисуем карточку с мягкой тенью
        card_w, card_h = W - card_margin, H - card_margin
        card = Image.new("RGBA", (card_w, card_h), (255, 255, 255, 255))
        shadow = Image.new("RGBA", (card_w, card_h), (0, 0, 0, 60))
        # Наклеиваем тень и карточку
        img.paste(shadow, (10, 10), shadow)
        img.paste(card, (20, 20), card)

        # Рисуем аватар (квадратный, без закругления) если есть
        avatar_space = 0
        if avatar_bytes:
            try:
                av = Image.open(io.BytesIO(avatar_bytes)).convert("RGBA")
                av = av.resize((150, 150))
                img.paste(av, (60, 60), av)
                avatar_space = 160  # сдвиг текста вправо
            except Exception:
                avatar_space = 0

        # Позиции текста
        x0 = 60 + avatar_space
        y0 = 80

        # Имя (крупный шрифт)
        try:
            draw.text((x0, y0), name, font=self.font, fill=(30, 30, 30, 255))
        except Exception:
            draw.text((x0, y0), name, fill=(30, 30, 30, 255))

        # Текст цитаты — обёртка по пикселям
        text_block_width = W - x0 - 60
        lines = await self._wrap_text_lines(draw, text, self.smallfont, text_block_width)

        y = y0 + 70
        line_h = (self.smallfont.size if hasattr(self.smallfont, "size") else 18) + 8
        for line in lines:
            try:
                draw.text((x0 - avatar_space//2, y), line, font=self.smallfont, fill=(20, 20, 20, 255))
            except Exception:
                draw.text((x0 - avatar_space//2, y), line, fill=(20, 20, 20, 255))
            y += line_h
            # защита — чтобы не выйти за пределы карточки
            if y > H - 120:
                break

        # Финальная подпись
        try:
            draw.text((60, H - 60), f"— {name}", font=self.smallfont, fill=(80, 80, 80, 255))
        except Exception:
            draw.text((60, H - 60), f"— {name}", fill=(80, 80, 80, 255))

        # Сохраняем в вебпоподобном контейнере (PNG) и отсылаем
        bio = io.BytesIO()
        bio.name = "quote.png"
        img.save(bio, "PNG")
        bio.seek(0)

        # Отсылаем как файл (Telegram примет изображение)
        await m.client.send_file(m.chat_id, bio)
        try:
            await m.delete()
        except Exception:
            pass

    # ----- команда вручную .fquotes <user> <text>
    @loader.command()
    async def fquotes(self, m):
        """.fquotes <юзер> <текст> — создать фейковую цитату"""
        args = utils.get_args_raw(m)
        if not args:
            return await m.edit("Использование:\n.fquotes @user текст")

        parts = args.split(" ", 1)
        if len(parts) < 2:
            return await m.edit("Нужно: .fquotes <юзер> <текст>")

        user, text = parts[0], parts[1]

        # получаем entity и аватар если возможно
        try:
            ent = await m.client.get_entity(user)
        except Exception:
            return await m.edit("Не удалось получить пользователя/юзера")

        avatar_bytes = None
        try:
            avatar_bytes = await m.client.download_profile_photo(ent, bytes)
        except Exception:
            avatar_bytes = None

        name = getattr(ent, "first_name", None) or getattr(ent, "username", None) or str(user)
        await self.make_sticker(m, text, name, avatar_bytes)

    # ----- команда по reply .fquo <текст>
    @loader.command()
    async def fquo(self, m):
        """.fquo <текст> — создать фейковую цитату в ответ на сообщение"""
        if not m.is_reply:
            return await m.edit("Ответь на сообщение!")

        reply = await m.get_reply_message()
        if not reply:
            return await m.edit("Ошибка: нет реплая")

        # текст для цитаты
        text = utils.get_args_raw(m)
        if not text:
            return await m.edit("Напиши текст цитаты после команды")

        # имя и аватар исходного отправителя
        sender = reply.sender
        name = getattr(sender, "first_name", None) or getattr(sender, "username", None) or "User"
        avatar_bytes = None
        try:
            avatar_bytes = await m.client.download_profile_photo(sender, bytes)
        except Exception:
            avatar_bytes = None

        await self.make_sticker(m, text, name, avatar_bytes)